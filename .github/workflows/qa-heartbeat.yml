name: QA Heartbeat

permissions:
  contents: write

\n\npermissions:\n  contents: write\n\n
on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch:

jobs:
  update-feed:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Smoke checks (optional)
        id: smoke
        shell: bash
        run: |
          set -e
          status=ok
          summary="Automated QA heartbeat"
          failures=0
          check() { url="$1" ; name="$2" ; if [ -n "$url" ]; then curl -sS --max-time 10 "$url" >/dev/null || { echo "::warning:: $name failed" ; failures=$((failures+1)) ; } ; fi }
          check "${{ secrets.SMOKE_RPC_URL }}" "RPC"
          check "${{ secrets.SMOKE_BOT_API }}/health" "Bot API"
          check "${{ secrets.SMOKE_DASHBOARD_URL }}" "Dashboard"
          if [ "$failures" -gt 0 ]; then status=fail ; summary="Automated QA heartbeat - smoke failed ($failures)" ; fi
          echo "status=$status" >> "$GITHUB_OUTPUT"
          echo "summary=$summary" >> "$GITHUB_OUTPUT"
      - name: Install Octokit
        run: npm install @octokit/rest
                  - name: Update QA feeds
        id: update
        continue-on-error: false
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          STATUS: ${{ steps.smoke.outputs.status }}
          SUMMARY: ${{ steps.smoke.outputs.summary }}
        run: |
          node scripts/update_pages_feed.js
      - name: Fallback update via API on failure
        if: steps.update.outcome == 'failure'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node - <<'NODE'
          const { Octokit } = require("@octokit/rest");
          const { randomUUID } = require("crypto");
          (async () => {
            const token = process.env.GITHUB_TOKEN;
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
            const octokit = new Octokit({ auth: token });
            const path = "data/qa-results.json";
            let arr = [];
            try {
              const res = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', { owner, repo, path });
              const parsed = JSON.parse(Buffer.from(res.data.content, "base64").toString("utf8"));
              arr = Array.isArray(parsed) ? parsed : [parsed];
            } catch (e) { if (e.status !== 404) throw e; }
            arr.push({ id: randomUUID(), repo, ts: new Date().toISOString(), status: "ok", summary: "Automated QA heartbeat (fallback)" });
            const newJson = JSON.stringify(arr, null, 2);
            const contentB64 = Buffer.from(newJson, "utf8").toString("base64");
            let sha;
            try { const res = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', { owner, repo, path }); sha = res.data.sha; } catch (e) {}
            await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', { owner, repo, path, message: "Update QA feed: fallback", content: contentB64, branch: "main", sha });
          })().catch(err => { console.error(err); });
          NODE
      - name: Slack alert on failure (optional)
        if: steps.smoke.outputs.status == 'fail' && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"$GITHUB_REPOSITORY QA heartbeat failed: ${{ steps.smoke.outputs.summary }}\"}" "$SLACK_WEBHOOK_URL"